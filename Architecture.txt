--------------------------------------------Informacje-------------------------
* RISC
* 32 bit
* 16 op
* 4 Register
* Register 5 RAM location
* r in 16 bit
* compare from R1 and R2 Zasada from R3
* Compare 0 > , 1 = , 2 <, 3 <=, 4 !=, 5 >=
* jmp need compare data 1
* jmp to disk need set location
---------------------------------------------OP--------------------------------
0. NULL
1. R -> M
2. M -> R
3. JMP
4. ALU
5. GET
6. OUT
7. R -> R
8. R -> D
9. 
A. wait for input
B. Compare
C.
D. jmp to disck
E. D -> R
F. Stop

-----------------------------------------OPIS---------------------------------
0. OP - OP - OP
1. OP - R - M(location)
2. OP - R - M(location)
3. OP - R - R3
4. OP - null - null
5. OP - R - Null
6. OP - R - Null
7. OP - R(z) - R(do)
8.
9.
a. OP - null - null
b. OP - Null - Null

d. OP - Register - null
e. OP - Register - null
f. OP - NULL - NULL
-----------------------------------------------ALU----------------------------
* 1 and 2 OP Register
* alu op register 0
* R 4 resoult

-----------------------------------------------ALU OP----------------------------
0. A
1. not A
2. AND
3. OR
4. XOR
5. NAND
6. NOR
7. ff
8. 00
9. ADD
A. Sub
B. Mult
C. Devider
D.
E.
F.
----------------------------------Asambler funkcje----------------------------
- pri ""-> wypisz ciąg znaków do w ""
- nel -> go to next line
- var (R) "" -> Ustaw rejsetr na ""
- prr (R źru) (R cel) -> z rejestru do rejestru
- out (R)-> wypisz z (rejestru)
- get (R) -> Get from keybord
- sme (R) -> Set data from (Register) to memory location = R4
- gme (R) -> get from memory to (Register) location = R4
- alu ""{
	A
	noA
	AND
	OR
	XOr
	Nad
	NOR
	ff
	00
	add
	sub
	mult
	Dev
}
-com -> Ustawienie 1 umożliwia wykonanie skoku a 0 nie
* jmp to disck
* jmp (R) -> jump to (z rejestru) Register3 = disck to jump


